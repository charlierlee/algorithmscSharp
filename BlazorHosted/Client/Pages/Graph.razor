@page "/graph"
@inject IJSRuntime JsRuntime


<PageTitle>Graph</PageTitle>

<h1>Load Graphs</h1>

<InputTextArea rows="5" class="form-control" @bind-Value="GraphText" placeholder="insert graph here" />
 <dl>
  <dt>Nodes</dt>
  <dd> <input type="number" class="form-control" style="max-width:100px;"
        @bind="NodeCount" @bind:event="oninput" step="1" min="1" max="12" /></dd>
  <dt>Edges</dt>
  <dd><input type="number" class="form-control" style="max-width:100px;"
        @bind="EdgeCount" @bind:event="oninput" step="1" min="@NodeCount" /></dd>
</dl>
<div>
    <button class="btn btn-primary" onclick="@LoagGraph">Load</button>
    <button class="btn btn-primary" onclick="@GenerateGraph">Generate</button>
</div>
<div @ref="_inputGraphRenderTo"></div>
<div>@((MarkupString)inputDotDiagram)</div>
<div>
    <button class="btn btn-primary" onclick="@BellmanFord">compute shortest paths</button>
</div>
<div @ref="_bellmanFordGraphRenderTo"></div>
<div>@((MarkupString)bellmanFordDotDiagram)</div>
@code {
    private ElementReference _inputGraphRenderTo;
    private ElementReference _bellmanFordGraphRenderTo; 
    private int NodeCount = 5;
    private int EdgeCount = 8;
    private int StartingVertex = 1;
    private string GraphText 
= @"5 8
1 2 2
1 5 3
2 4 -2
3 1 1
4 1 4
4 3 1
4 5 2
5 3 -1
1";
    private string inputDotDiagram = "";
    private string bellmanFordDotDiagram = "";
    private Lib.Graphs.MathGraph<int> inputGraph;
    private async Task LoagGraph()
    {
        var diagramModule = await JsRuntime
            .InvokeAsync<IJSObjectReference>("import", "/diagrams.js");

            string[] lines = GraphText.Split("\n");
            inputGraph = new Lib.Graphs.MathGraph<int>(true);
            Lib.Graphs.MathGraph<int>.LoadGraph(inputGraph, lines);
            inputDotDiagram = inputGraph.GenerateDot();


        await diagramModule.InvokeVoidAsync("renderDot", inputDotDiagram, _inputGraphRenderTo);
    }
    private async Task GenerateGraph()
    {
        var diagramModule = await JsRuntime
            .InvokeAsync<IJSObjectReference>("import", "/diagrams.js");

            if(NodeCount >= EdgeCount-1){
                NodeCount = EdgeCount - 2;
            }
            inputGraph = GenerateRandomGraph(NodeCount, EdgeCount);
            inputDotDiagram = inputGraph.GenerateDot();


        await diagramModule.InvokeVoidAsync("renderDot", inputDotDiagram, _inputGraphRenderTo);
    }
    public Lib.Graphs.MathGraph<int> GenerateRandomGraph(int Nodes, int Edges){
        var connectedGraph = float.PositiveInfinity;
        Lib.Graphs.MathGraph<int> graph = new Lib.Graphs.MathGraph<int>(true);
        while(connectedGraph == float.PositiveInfinity){
            graph = new Lib.Graphs.MathGraph<int>(true);
            graph.GenerateGraph(Nodes, Edges, graph);
            var bellmanDist = graph.BellmanFord(StartingVertex);
            if(bellmanDist != null){
                connectedGraph = bellmanDist.Item1.Sum(x => x.Value);
            }
        }
        GraphText = graph.GenerateAdjacentList();
        return graph;
    }
    private async Task BellmanFord()
    {
        var diagramModule = await JsRuntime
            .InvokeAsync<IJSObjectReference>("import", "/diagrams.js");

        var data = inputGraph.BellmanFord(StartingVertex);
        if(data!=null)
        {
            Lib.Graphs.MathGraph<int> graph = new Lib.Graphs.MathGraph<int>(true);
            Lib.Graphs.MathGraph<int>.LoadGraph(graph, data);
            bellmanFordDotDiagram = graph.GenerateDot();
            await diagramModule.InvokeVoidAsync("renderDot", bellmanFordDotDiagram, _bellmanFordGraphRenderTo);
        }
    }
}